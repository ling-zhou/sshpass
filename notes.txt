# vim:ft=conf

# man posix_openpt
# man pts
# man pty
# man tty
# https://www.reddit.com/r/learnprogramming/comments/27v0l4/masterslave_pty/
# https://dvdhrm.files.wordpress.com/2013/08/vt_txt.png
# https://dvdhrm.wordpress.com/2013/08/24/session-management-on-linux/
# http://www.linusakesson.net/programming/tty/
# https://unix.stackexchange.com/questions/117981/what-are-the-responsibilities-of-each-pseudo-terminal-pty-component-software
# https://stackoverflow.com/questions/34686940/pty-tty-what-cant-you-do-with-only-slave-fd

A pty is a device that provides two __device files__ and allows programs that expect to be
connected to a terminal to be connected to another program instead of a physical terminal.

The slave end is a __device file__ that behaves just like a device file for a __physical terminal__.
The slave end is where your pico process is connected.

The master end is the end where the program that does the job of the physical terminal connects.
This program is responsible for sending input characters into the pty to be read as input by the
slave program, and for reading and interpreting characters from the pty, which have been written
out by the slave program.

/dev/ptmx is the "pseudo-terminal master multiplexer". Opening it returns a file descriptor
of a __master node__ and causes an associated __slave node__ /dev/pts/N to be created.

UNIX 98 pseudoterminals
   An unused UNIX 98 pseudoterminal master is opened by calling
   __posix_openpt__(3).  (This function opens the __master clone device__,
   __/dev/ptmx__; see pts(4).)  After performing any program-specific
   initializations, changing the ownership and permissions of the
   slave device using __grantpt__(3), and unlocking the slave using
   __unlockpt__(3)), the corresponding slave device can be opened by
   passing the name returned by __ptsname__(3) in a call to open(2).

When a process opens /dev/ptmx, it gets a file descriptor for a pseudoterminal master (PTM),
and a __pseudoterminal slave__ (PTS) device is created in the /dev/pts directory.
Each file descriptor obtained by opening /dev/ptmx is an __independent PTM__ with its own
associated PTS, whose __path__ can be found by passing the descriptor to __ptsname__(3).

Before opening the pseudoterminal slave, you must pass the master's file descriptor to
__grantpt__(3) and __unlockpt__(3).

Once both the pseudoterminal master and slave are open, __the slave__ provides __processes__
with an interface that is identical to that of a __real terminal__.

Data written to the slave is presented on the master descriptor as input.
Data written to the master is presented to the slave as input.

In practice, pseudoterminals are used for implementing terminal emulators such as xterm(1),
in which data read from the pseudoterminal master is interpreted by the application in the
same way a real terminal would interpret the data, and for implementing remote-login programs
such as sshd(8), in which data read from the pseudoterminal master is sent across the network
to a __client program__ that is connected to a terminal or terminal emulator.

BSD-style pseudoterminals are considered __deprecated__

FILES
       /dev/ptmx (UNIX 98 master clone device)
       /dev/pts/* (UNIX 98 slave devices)
       /dev/pty[p-za-e][0-9a-f] (BSD master devices)
       /dev/tty[p-za-e][0-9a-f] (BSD slave devices)

A pseudoterminal (sometimes abbreviated "pty") is a pair of
virtual character devices that provide a bidirectional
communication channel.  One end of the __channel__ is called the
__master__; the other end is called the __slave__.

# https://unix.stackexchange.com/questions/117981/what-are-the-responsibilities-of-each-pseudo-terminal-pty-component-software
A user accesses a pseudo-TTY device through the master device (called ptm)
that in turn is accessed through the clone driver.

# https://www.linusakesson.net/programming/tty/
The TTY driver keeps track of the foreground process group id, but only in a passive way.
The __session leader__ has to update this information explicitly when necessary. Similarly,
the TTY driver keeps track of the size of the connected terminal, but this information has
to be updated explicitly, by the terminal emulator or even by the user.

As you can see in the diagram above, several processes have /dev/pts/0 attached to their standard
input. But only the __foreground job__ (the ls | sort pipeline) will receive input from the TTY.
Likewise, only the foreground job will be allowed to write to the TTY device
(in the default configuration). If the cat process were to attempt to write to the TTY,
the kernel would suspend it using a signal.

# https://www.compuhoy.com/what-is-tty-and-pts-in-linux/
What does pts mean in Linux?
A tty is a native terminal device, the backend is either hardware or kernel emulated.
A pts (pseudo terminal device) is a terminal device which is emulated by an other program
(example: xterm, screen, or ssh are such programs).

What does pts mean in TTY?
PTS: Stands for the pseudo terminal slave. The difference between TTY and PTS is the type of
connection to the computer. TTY ports are direct connections to the computer such as a
keyboard/mouse or a serial connection to the device.

What is a pseudo terminal in Linux?
A pseudo-terminal is a special interprocess communication channel that acts like a terminal.
One end of the channel is called the master side or master pseudo-terminal device, the other
side is called the slave side. â€¦ Allocating a pseudo terminal.

What is Dev PTMX?
What is ptmx: The file /dev/ptmx is a character file with major number 5 and minor number 2,
usually of mode 0666 and owner. group of root. root. It is used to create a pseudoterminal
master and slave pair.
